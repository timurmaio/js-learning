package dataStructures.sets

/**
 * Система непересекающихся множеств.
 *
 * Ограничения на элементы множества: целые числа от 0 до Int.MAX_VALUE.
 *
 * Реализация - множество деревьев, где каждое дерево представляет собой отдельное непересекающееся множество.
 * Каждый узел дерева хранит ссылку на предка в дереве.
 * Однако, ради эффективности, деревья виртуальные, ссылка на родителя заменяется массивом предков.
 * Представитель множества - это корень дерева, представляющего собой одно непересекающееся множество.
 */
class Disjoint(count: Int) {
    /**
     * Массив, в котором для каждого элемента хранится его предок в множестве деревьев.
     *
     * Т.е. если индекс - номер элемента, то значение в массиве по этому индексу это предок элемента в дереве.
     */
    private val parent: Array<Int> = Array(count, { 0 })

    /**
     * Массив, в котором для каждого представителя дерева хранится верхняя граница высоты этого дерева.
     */
    private val rank: Array<Int> = Array(count, { 0 })

    /**
     * Создание множества, содержащего данный элемент.
     */
    fun makeSet(x: Int) {
        parent[x] = x
    }

    /**
     * Поиск множества, содержащего данный элемент.
     *
     * @return Идентификатор множества (представитель), в котором содержится данный элемент.
     *
     * Сложность: O(m*a(n,m)), где m - общее количество операций над системой, a() - обратная функция Аккермана.
     */
    fun find(x: Int): Int {
        if (x != parent[x]) {
            // эвристика сжатия пути:
            // все вершины, через которые пройдёт поиск,
            // будут прикреплены к представителю
            parent[x] = find(parent[x])
        }

        return parent[x]
    }

    /**
     * Объединение множеств, содержащих данные элементы.
     */
    fun union(x: Int, y: Int) {
        val xRepresentative = find(x)
        val yRepresentative = find(y)

        if (xRepresentative == yRepresentative) {
            return
        }

        // эвристика объединения по рангу -
        // подвешиваем дерево с меньшим рангом
        // к дереву с бОльшим рангом
        // также было замечено, что можно подвешивать
        // деревья произвольно без особых потерь в скорости
        if (rank[xRepresentative] > rank[yRepresentative]) {
            parent[yRepresentative] = xRepresentative
        }
        else {
            parent[xRepresentative] = yRepresentative

            if (rank[xRepresentative] == rank[yRepresentative]) {
                rank[yRepresentative] = rank[yRepresentative] + 1
            }
        }
    }

    /**
     * Проверка, находятся ли два элемента в одном множестве.
     */
    fun check(x: Int, y: Int): Boolean {
        return find(x) == find(y)
    }
}
