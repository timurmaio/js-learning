# Начнём изучение Lisp!
## Введение:
Напишем тривиальное a+b:

    (+ 2 3) ; 5
Сигнатура функций в Lisp: **(имя_функции  аргумент_1  аргумент_2 ...)**

Аргументами функции могут выступать другие функции:

    (* (+ 2 2) (- 11 1)) ; 40
Напишем свою функцию:

    (defun имя_функции(аргумент_1  аргумент_2 ...)
      (функция_1
        (функция_2
        ...
        )))
Напишем функцию увеличения числа на 1:

    (defun inc(chislo)(+ chislo 1))
Рассмотрим предикат, как и в алгебре логики, это функция, которая возвращает правду или ложь, соответственно T и NIL. Любой объект отличный от NIL интерпретируется как T. Обычно предикаты заканчиваются на букву p:

    (defun isdigitp(chislo)
        (if(< chislo 10) chislo NIL)
        )
Таким образом наш предикат возвращает само число, если она цифра, и NIL в обратном случае.
## Типы данных Lisp:
В Lisp существует только два типа переменных: **атомы** и **списки**. **Атомы** — неделимые объекты, все остальные объекты представлены в виде списков. Таким образом **списки** являются универсальным объектом, который может хранить в себе как код, так и значения, следовательно может объединять в себе множество элементов различной сложности. В языке Lisp **объект**, а **не переменная** имеет привычный нам тип данных. Конечно можно ввести некоторые ограничения на переменную, но их можно обойти. **Объект** в Lisp может принадлежать нескольким типам данных, поэтому очень интересно узнать, а принадлежит ли данный объект этому типу данных. Если объект принадлежит всем типам данных, то он обозначается как T(true), если не принадлежит ни к одному, то NIL(false). Существует также тип **common**, который представляет из себя множество типов, которые обязательны для любой реализации Lisp. Для того, чтобы проверить относится ли данный тип данных к common используют предикат commonp. Теперь рассмотрим базовые **типы данных**:

* **Числа** — обычные числа целые и вещественные, переходят друг в друга при понятных условиях, также возможна работа и с комплексными числами
* **Буквы** — обычные печатные символы текста
* **Символы** — отличие символов от букв в области применения, используются для именования функций и переменных.
* **Списки** — некоторая последовательность данных, пустой список эквивалентен NIL.
* **Массивы** — набор однотипных данных, к которым можно обращаться по индексу. Lisp поддерживает любое положительное количество измерений и любую целочисленную индексацию.
* **Хэш-таблицы** — множество пар ключ — значение, к которым возможен доступ через ключ
* **Таблицы чтения** — служат для модификации работы анализаторов Lisp.
* **Пакеты** — как и в любом другом языке программированию служат для разграничения пространства имен, иными словами служат для устранения конфликтов с именованием переменных
* **Путевые имена** — имена файлов
* **Потоки** — некоторые интерфейсы для доступа(чтения) или вывода(записи) информации
* **Случайные ячейки** — ячейки, которые использует генератор случайных чисел
* **Структуры** — пользовательский тип данных, который представляет из себя некоторый набор базовых типов
* **Функции** — некоторый набор команд(функций), который возвращает значение
* **Сигналы** — специальный тип данных, который используют для управлением ходом исполнения программы
* **Классы** — сложный объект в Lisp, который задает поведение для своих экземпляров.
* **Методы** — функции без аргументов, которые находятся в классе.
* **Обобщенные функции** — функция, которая в своей реализации содержит некоторый набор функций

К атомам в языке Lisp относят цифры и символы. Напишем проверку этого факта:

        (defun isatomp(atom)
    (or (numberp atom) (symbolp atom)))
Теперь проверим нашу функцию:

    (isatomp 1)
    T
    (isatomp 'symbol)
    T
## Символы в Lisp:
**Основное назначение символов в Lisp это использование их в качестве переменных**. Им может стать любая последовательность печатных символов, кроме кавычек и пробела. **В языке Lisp регистр символов не учитывается**:

    symbol
    Symbol
    SymboL ; идентичны
Так как в качестве символов можно использовать достаточно большой набор значений, то они могут принимать достаточно специфичный вид:

    symbol.io ; символ с точкой
    symbol..io ; две точки подряд запрещены
    symbol/io/lisp ; символ с косой чертой
    100500+ ; символ из чисел и знака плюс
    +100500 ; уже число
Таким образом символ является аналогом переменных в других языках. Он сам по себе не имеет никакого типа, но объект, который лежит по данному символу имеет тип. Любой символ имеет печатное имя, с помощью которого вы сможете обращаться к нему. Кроме этого, в языке Lisp есть механизмы, которые позволяют использовать уникальные имена для переменных. Таким образом символы разделены по пакетам, которые позволяют лучше их структурировать. Кроме этого существует возможность манипулировать набором свойств символа с помощью **plist**. В нем на чётных местах расположены названия свойств, а на нечетных значения. **Так как символ это название переменной, то лучше все таки называть их осмысленно.**

**Не нужно называть символом зарезервированные слова.** Например, нельзя использовать t в качестве символа, так как компилятор выдаст ошибку, t - это константа, и ее нельзя использовать в качестве переменной.

## Списки в Lisp:
Списки в языке программирования Lisp состоят из CONS ячеек, где каждая ячейка состоит из двух частей:

* CAR — первая часть ячейки, определяет значение в текущей ячейке
* CDR — ссылка на следующую cons ячейку

Таким образом, если у вас есть список (a b c), то CAR вернет первый элемент в списке - a. А функция CDR вернет на том же списке (b c). Если мы применим функции CAR и CDR на списке ((a b) c), то CAR — (a b), а CDR — c. Пустой список обозначается как NIL. NIL имеет двойственную природу, он единственный элемент в Lisp является и списком и атомом. Таким образом становится понятно, что последний элемент списка является NIL. Так LISP понимает, что ваш список закончен. Кроме этого, вы можете явно указать последний элемент, таким образом CDR часть последнего элемента будет указывать на другой элемент, который может и не быть CONS ячейкой.

Пример:

    (car '(a b c)) ; a
    (car '((a b) c)) ; (a b)
    (cdr '(a b c) ; (b c)
    (cdr '((a b) c)) ; c
Как вы могли заметить из примера, для того, чтобы задать список, который не содержит первым элементом функцию необходимо применять одинарную кавычку. Функция CONS формирует список из двух аргументов: первый аргумент данная функция использует как CAR — часть новой CONS ячейки, а вторую как CDR. Пример использования функции CONS:

    (cons 1 '(2 3)) ; (1 2 3)
    (cons '(2 3) 1) ; ((2 3) . 1)
Таким образом мы видим, что последовательность аргументов в CONS очень важна и ошибка в ней может привести к не очень интересным результатам. Что же означает точка после списка (2 3)? Она означает что вывели на экран CONS ячейку, у которой CDR ссылается на объект отличный от другой CONS ячейки, и он выводится на экран через точку. Теперь мне хотелось бы вам рассказать про дополнительные функции работы со списками. Очень интересное формирование имен происходит в языке Lisp. Вместо того, чтобы вызвать функция CAR, а затем CDR, можно вызвать функцию CADR. Данный способ именования функций встретится вам в языке Lisp еще не один раз. Очень полезной функцией для работы со списками является:

    (nth i list) ; возвращает i-ый элемент в списке
    (nth 0 '(1 2 3)) ; 1
    (nth 1 '(1 2 3)) ; 2
    (nth 2 '(1 2 3)) ; 3
Отсчёт начинается с 0.

Таким образом мы задаём список:

    (set 'list '(1 2 3 4 5)) ; list = (1 2 3 4 5)
## Переменные в Lisp:
Мы уже рассмотрели некоторые константы языка Lisp. Такие как NIL и T не вызывают у нас сомнения, но списки, в начале которых стоит кавычка, тоже являются константой. Кстати вместо кавычки можно конечно использовать слово quote, но это длинно, а эффект тот же самый. В качестве операторов присваивания в языке Lisp используются функции set и setq. Функция Set принимает на вход два аргумента, первый — имя переменной в которую вы хотите присвоить значение второго аргумента. Например:

    (set 'chislo 1)
    chislo ; 1
    (set 'list '(a b))
    list ; (a b)
Как вы могли заметить, для того, чтобы вывести значение переменной необходимо просто написать ее имя. Теперь рассмотрим функцию setq. Она уже не требует того, чтобы вы писали кавычку перед названием переменной:

    (setq chislo 1)
    chislo ; 1
    (setq list '(a b))
    list ; (a b)
Кроме того, следует понимать, что в Lisp переменные не имеют типа данных, таким образом в них можно класть все что угодно:

    (setq chislo 1)
    chislo ; 1
    (setq chislo '(a b))
    chislo ; (a b)
## Предикаты в Lisp:
Предикаты — это функция, проверяющая, обладают ли аргументы заданным свойством и возвращающая либо T либо NIL. Рассмотрим некоторые предикаты:

* atom — проверяет, является ли аргумент атомом
* listp — проверяет, является ли аргумент списком
* null — проверяет, является ли аргумент пустым списком или NIL
* eq — сравнивает аргументы, возвращает T, если равны и NIL в противном случае
* eql — тоже самое, но для объектов более высокого уровня, чем eq
* equal — еще более хорошее сравнение
* equalp — самое лучшее

С первыми тремя предикатами все понятно, поэтому просто приведем пример их использования:

    (atom 1) ; T
    (atom '(1 2)) ; NIL
    (listp '1) ; NIL
    (listp '(1 2)) ; T
    (null '1) ; NIL
    (null '()) ; T
    (null nil) ; T
Так теперь нужно разобраться с группой «сравнения». Самый первый предикат eq сравнивает ссылки у объектов, т.е он вернет T, только тогда, когда перед нами один и тот же объект:

    (eq 1 1);T
    (eq 'cybern 'cybern);T
    (eq NIL ());T
    (eq 1.0 1.0);NIL
    (setq x 1)
    (setq y 1)
    (eq x y);T
    (eq x x);T
    (setq x '(a b))
    (setq y '(a b))
    (eq x y);NIL
Таким образом eq смогла сравнить целые числа, NIL и (), строки, но уже не смогла сравнить вещественные числа и значения переменных cложных типов. Понятное дело, что там где справится eq, можно использовать и eql, поэтому мы прогоним eql только на тестах, на которых не справилась eq.

    (eql 1.0 1.0);T
    (eql 1 1.0);NIL
    (setq x '(a b))
    (setq y '(a b))
    (eql x y);NIL
Функция eql уже смогла сравнить вещественные числа, а в остальном пока что не помогла нам продвинуться вперед. Рассмотрим следующую функцию equal:

    (equal 1 1.0);NIL
    (setq x '(a b))
    (setq y '(a b))
    (equal x y);T
Таким образом функция equal может сравнивать объекты одной природы и возвращать правильный результат. Попробуем все таки сравнить объекты разной природы с помощью equalp:

    (equalp 1 1.0);T    
Таким образом мы можем использовать функция equalp для сравнения объектов даже разной структуры. На этом урок по предикатам закончен, можно переходить к следующему.
## Функции COND и IF в Lisp:
В данном уроке мы рассмотрим две функции COND и IF. Они являются операторами условия, т.е с помощью них вы сможете создать ветвление вашего алгоритма. Рассмотрим сигнатуру этих функций более подробно:

    (cond (предикат-1 результат-1)
          (предикат-2 результат-2)
        ...
        (предикат-n результат-n))
Из данного примера мы видим, что функция cond в LISP является некоторым аналогом функции case из других языков программирования. На вход она принимает n — пар предикат — значение. Как выполняется COND? Сначала просматриваются все предикаты в порядке следования, и если хоть один из них истинный, то cond возвращает результат, связанный с этим предикатом. Если ни один предикат не был истинным, то она вернет NIL. Рассмотрим следующий пример:

    (setq x 1)
    (cond ((listp x) (car x))
    ((atom x) x));1
Так как 1 не является списком, но является атомом то выведется просто 1. Теперь попробуем положить в x список:

    (setq x '(1 2))
    (cond ((listp x) (car x))
    ((atom x) x));1
Опять вывелась единица, так как взялось значение 1 из списка (1 2). Таким образом с помощью функции cond вы сможете задать зависимость поведения алгоритма от входных данных. Теперь рассмотрим сигнатуру функции if:

    (if условие оператор-1 оператор-2)
Таким образом, если вы проверяете только одно условие, то проще пользоваться оператором if. В случае, если условие истинно выполнится первый оператор, иначе второй. Кроме того, в рамках этого урока я хочу рассмотреть как можно составлять сложные условия. Рассмотрим первую функцию, которая поможет нам создавать такие условия, это отрицание. Функция NOT вернет на T NIL, а на NIL — T

    (if (not (atom '(1 2))) 'notatom);notatom
    (if (not (listp '(1 2))) 'nelist 'list);list
Предикат and аналогичен булевой функции «и». Таким образом проверим находиться ли число в промежутке между 0 и 9:

    (if (and (< 0 5) (< 5 9)) 'да);да
or — аналог булевой функции или. Реализуем проверку не принадлежности числа промежутку с 0 до 9:

    (if (or (> 0 5) (> 5 9)) 'да 'нет);нет
На самом деле предикаты and и or принимают на вход n-аргументов, результат для and будет истинным, если истинны все его члены, а для or результат будет истинным, если истинен хотя бы один его член. На этом мы закончим наше знакомство с условиями, и со способами их составления и перейдем к рекурсивным функциям.
## Рекурсивные функции:
Рекурсивная функция — это такая функция, которая вызывает сама себя с другими параметрами.Самое главное при реализации таких функций это реализовать условие выхода, т.е прописать такое условие, при котором рекурсивный вызов не случится, а сразу вернется какое — нить значение. Так как наши рекурсивные функции в основном будут работать над списками, то необходимо в первой строке проверить, а не передали ли нам пустой список, т.е не равен ли наш параметр нулю, если нет, то вызвать нашу функцию, для этого мы можем воспользовавшись функцией cond или if. Давайте напишем пример какой — нить простой рекурсии, например напишем подсчет факториала:

    (defun fuct(a)
    (if (equal a 0) 1 (* a (fuct (- a 1))))
    )
Таким образом нашу функция возвращает ноль, если мы ищем факториал от нуля и возвращает a * fuct(a-1) в ином случае. Проверим наше утверждение, действительно, при 0, факториал от нуля равен 1, при 1, у нас получается , что результат это 1 умноженная на факториал от нуля, который тоже равен 1, продолжив рассуждения мы получаем, что факториал для двух это 2 умножить на факториал единицы.
Теперь напишем более сложную рекурсию, реализуем функцию member, которая будет проверять, а содержится ли элемент a в списке lst:

    (defun member(lst a)
        (if null(lst)
            NIL
            (or (equal (car lst a)) (member (cdr lst) a))
        )
    )
Данная функция возвращает ложь, если список пустой, а если список не пустой мы берем его первый элемент и сравниваем с элементом а или запускаем функция member на оставшимся списке(без первого элемента), если хоть кто — нибудь вернет T, то результатом будем истина. Теперь напишем реализацию функции rember с помощью функции cond, данная функция будет удалять первое вхождение элемента в массив.

    (defun rember(lst a)
    (cond ((null lst) nil)
    ((equal (car lst) a) (cdr lst))
    (t (cons (car lst)(rember (cdr lst) a)))
## Лямбда — функции в Lisp:
В данном уроке мы научимся передавать функции в качестве параметра, а также познакомимся с лямбда функциями. В языке LISP имеется возможность вызывать функции по их имени:

    (funcall '+ 2 2);4
С таким же успехом название функции я мог бы передать как параметр в другой функции. Для чего это может быть нужно? Если у вас есть какая — то функция, которая работает только с каким — то определенным типом данных, но она могла бы стать более общей, если бы умела работать со всеми типами, тогда мы будем передавать название функции, которая умеет делать это с конкретным типом данных, а вызывать ее уже по имени внутри нашей функции. Длинная фраза, которая означает ровно то, что если ваша функция например реализует какой — то алгоритм сортировки, то так как объекты которые мы сортируем могут быть разной природы, целые числа, вещественные числа, какие — то списки и прочее, то мы возьмем и начнем передавать имя функции, которая будет сравнивать два конкретных объекта в функцию сортировки. Таким образом, вместо того, чтобы принимать на вход один список она будет принимать на вход и список и название функции, которая будет сравнивать конкретный тип данных. Для закрепления давайте напишем операцию rember c произвольной проверкой:

    (defun rember(testp lst a)
    (cond ((null lst) nil)
    ((funcall testp (car lst) a) (cdr lst))
    (t (cons (car lst)(rember testp (cdr lst) a)))
    ))
    (rember '< '(1 2 3 4 5) 2);(2 3 4 5)
Лямбда — выражение имеет следующую сигнатуру:

    (lambda (x1 ... xn) fn);сигнатура
    (lambda (x y) (+ x y));пример
Где x1, x2 и так далее формальные параметры, а fn — это тело функции.
Для того, чтобы вызвать лямбда выражение достаточно поставить его на место функции:

    ((lambda (x y) (+ x y)) 1 1);2
Вычисление лямбда функций происходит в два этапа: сначала вычисляются фактические параметры и связываются с формальными, а затем уже происходит выполнение функции. В чем плюс использования лямбда функции? В том, что мы можем возвращать не только целые числа и так далее, но и функции. Давайте напишем функцию myeq, которая будет возвращать функция без имени, которая будет сравнивать некоторой значение, с значением, которое мы будем передавать в myeq:

    (defun myeq (a)
    (function (lambda (x) (equal x a)))
    )
    (funcall (myeq 1) 1);T
Работа с лямбда функциями дает громадные возможности по расширению возможностей ваших функций, а также может помочь повысить уровни абстракции. Кроме этого, вы также можете положить вновь полученную функцию в какую — нибудь переменную и вызывать с помощью funcall:

    (setq func (myeq 1))
    (funcall func 1);T
## Циклы в Lisp:
Бывают моменты, когда рекурсия не очень удобна, тогда следует применять циклы. Рассмотрим сначала классический цикл на основе оператора do:

    (do
    (
    (переменная-по-которой-будет-пущен-цикл начальное-значение следующий-шаг);может быть много переменных
    )
    (
    (условие-выхода)
    результат-который-нужно-возвратить
    )
    (операторы-которые-будут-выполнятся-на-каждом-шаге-цикла)
    )
Конечно может быть для первого раза данный код выглядит чутка сложно, но давайте реализуем функцию, которая будет в переменную sum складывать значения с 0 до 10:

    (setq sum 0);0
    (do
    ( ( i 1 (+ i 1)))
    ( (> i 10) sum)
    (setq sum (+ sum i)));55
Менее массивны, и не являются хорошим тоном использование следующих функций:
Бесконечный цикл:

    (loop do действие)
Цикл for:

    (loop for i from 1 to 10 do действие)
