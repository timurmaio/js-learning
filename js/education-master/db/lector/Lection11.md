# Lection 11
==========================================================

## Введение в БД

### Создание индексов.
------------------

При выполнении запроса вида:
 SELECT А.а FROM А WHERE id=65;

Система будет сканировать всю таблицу А, строку за строкой, чтобы найти все соответствующие записи. Если в А много строк и только несколько строк (может быть ноль или одна), которые будут возвращены на такой запрос, то это явно неэффективный метод. Но, если системе было поручено поддерживать индекс столбца ID, то он может использовать более эффективный метод для обнаружения подходящих строк. Например, может лишь пройти несколько уровней вглубь дерева поиска.

Следующая команда может быть использована для создания индекса по столбцу ID:
 > CREATE INDEX test1_id_index ON test1 (ID);    
 
имя Test1_id_index может быть выбрано любое, но оно должно позволять вам запомнить, для чего этот индекс.

Чтобы удалить индекс, используйте команду:
> INDEX DROP.

 Индексы могут быть добавлены и удалены из таблицы в любое время.

Когда индекс создается, никаких дополнительных вмешательств не требуется: система обновит индекс при изменении таблицы, и будет использовать индекс в запросах, когда решит, что это будет более эффективным, чем последовательное сканирование таблицы. Но вам, возможно придётся регулярно выполнять команду ANALYZE, обновляющую статистику, чтобы планировщику запросов принимать компетентные решения. 

* Индексы также могут воспользоваться в командах UPDATE и DELETE с условиями поиска. 
* Индексы могут быть использованы в поисках со связью таблиц (JOIN). Таким образом, индексы определены на столбце, который является частью условия и могут также значительно ускорить запросы с соединениями.

Создание индекса в большой таблице может занять длительное время. По умолчанию, PostgreSQL позволяет читать (выбирать) из таблицы, параллельно с созданием индекса, но блокирует запись (вставку, обновление и удаление) до конца построения индекса. В производственной среде это часто неприемлемо. Можно позволить запись параллельно с созданием индекса, но есть несколько предостережений, о которых надо быть в курсе - для получения дополнительной информации см. создание индексов без блокировки .

После того, как индекс будет создан, система должна поддерживать ее синхронизированным с таблицей. Это добавляет дополнительные расходы на операции с данными. Поэтому индексы, которые редко или никогда не используются в запросах должны быть удалены.

### Типы индексов:

PostgreSQL предлагает несколько типов индексов:  
 
* B-tree (сбалансированное дерево). По умолчанию, команда CREATE INDEX создает B-tree индексы, которые соответствуют наиболее распространенным ситуациям. Сам алгоритм представляет собой поиск по дереву. Например: нам нужно найти значение 53. Начнём с корневого узла, содержащего значение 40, оно сравнивается с искомым значением. Поскольку 53 > 40, то далее мы следуем по правой ветви дерева и т.д.   
<u>За счёт чего этот алгоритм ускоряет поиск:</u>  
Значения (ключи) внутри каждого узла отсортированы.  
Алгоритм сбалансирован: ключи равномерно распределены по узлам, что позволяет минимизировать количество переходов. Каждая ветвь ведёт к дочернему узлу, содержащему примерно такое же количество ключей, что и все остальные дочерние узлы.

* HASH - индекс, обрабатывающий простые сравнения и равенства (использовать не рекомендуется).  

* GiST - некая инфраструктура, в которой может быть реализованы много различных стратегий индексирования.  

* GIN (перевернутые индексы) - индексы, которые могут обрабатывать значения, содержащие более одного ключа, например, массив.
  
**<u>Создадим индексы для нашей базы данных:</u>**   

CREATE INDEX id_person ON persons(id);  
CREATE INDEX id_student ON students(id);  
CREATE INDEX id_group ON groups(id);  
CREATE INDEX id_subject ON subjects(id);  
CREATE INDEX id_professor ON professors(id);  
CREATE INDEX id_class ON classes(id);  


